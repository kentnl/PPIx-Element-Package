# NAME

PPIx::Element::Package - Derive the package an element is defined in

# VERSION

version 0.001000

# SYNOPSIS

    use PPI;
    use PPIx::Element::Package;

    # Do your normal PPI stuff here.

    # Get the logical enclosing package or undef if one cannot be discovered
    my $package = $element->x_package;

    # Get the name of the logical enclosing package, or main if one cannot be discovered
    my $namespace = $element->x_package_namespace;

# DESCRIPTION

This module aims to determine the scope any [`PPI::Element`](https://metacpan.org/pod/PPI::Element)
( which includes [`Nodes`](https://metacpan.org/pod/PPI::Node) and [`Tokens`](https://metacpan.org/pod/PPI::Token) ) is defined in.

It adds two utility methods on the `PPI::Element` class as follows:

- `x_package` - The Logical [`PPI::Statement::Package`](https://metacpan.org/pod/PPI::Statement::Package) that owns the `Element`
- `x_package_namespace` - The name-space of the logical `PPI::Statement::Package` that owns the element.

The latter of these is just a convenience wrapper on top of `x_package` that
returns `main` when either the owning `Statement::Package` cannot be found,
or when the owning `Statement::Package`'s name-space is somehow undefined.

# Extension Methods

## x\_package

Find the logical "owner" package of an `Element`

    my $package = $element->x_package;

Returns `undef` if one cannot be found.

## x\_package\_namespace

Find the name-space of the logical owner package.

    my $package = $element->x_package_namespace;

Returns `main` if one cannot be found, or one can be found and its `namespace` value is not defined.

# FUNCTIONS

## find\_package

Call this function if you want to avoid using the `x_` functions on the elements themselves.

    my $package = PPIx::Element::Package::find_package( $element );

# LOGIC

Here lies the assumptions that this module uses to find the `Package`:

- 1. That any node that has children nodes implies a lexical scope.
- 2. That within a given lexical scope, the first `Package` sibling prior
to a given Element is the `Owner` package.
- 3. In the event a given lexical scope has no `Package` declarations
between the Element and the first child of that lexical scope, that the
`Package` can be derived from the position of the scope itself, by re-applying
rules 1 and 2 recursively upwards until the `Document` is reached.
- 4. Any nodes that are `PPI::Statement::Package` are contained _within_
**themselves**, that is:

        package Foo; # This Whole line is inside "Foo"
        package Bar; # This Whole line is inside "Bar"

- 5. And subsequently, any children of a `PPI::Statement::Package` `Node`
(which are the tokens themselves that compose the statement) are themselves
within that package. ( This is just a logical extension of #4 ).

The biggest scope I presently have for error in these assumptions is in the
assumptions about Package scope being determinable from the `PPI` document
hierarchy, which may lead to an over-eager presumption that a lexical scope
exists where one may not exist.

However, under my testing so far this approach has proven more useful and
accurate than manually traversing the tokens and only declaring scopes on
`Block` boundaries.

# SEE ALSO

## `PPIx::LineToSub`

I initially tried using [`PPIx::LineToSub`](https://metacpan.org/pod/PPIx::LineToSub), however,
in testing it proved far too sloppy for my uses, and having no support for
lexical contexts at all and is entirely oriented on a
"new package overrides previous package" principle.

Its is also limited for my use cases in that it is entirely line oriented,
so cases like this are intractably insolvable:

    package Quux; { package Foo; baz() } bar();

Answering "what package is on this line" is not even a sensible question to
ask there.

It has however a performance advantage due to being a single-pass indexing
sweep with all subsequent checks being a simple array look-up.

# AUTHOR

Kent Fredric &lt;kentnl@cpan.org>

# COPYRIGHT AND LICENSE

This software is copyright (c) 2015 by Kent Fredric &lt;kentfredric@gmail.com>.

This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
